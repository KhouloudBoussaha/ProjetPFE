{"ast":null,"code":"import { throwError } from 'rxjs';\nimport { catchError, finalize, tap } from 'rxjs/operators';\nimport { jwtDecode } from 'jwt-decode';\nimport { environment } from 'src/environments/environments';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@angular/router\";\nexport class AuthService {\n  constructor(http, router) {\n    this.http = http;\n    this.router = router;\n    this.apiUrl = `${environment.apiUrl}/api/auth`;\n    /**\n     * D√©connecte l'utilisateur en supprimant les donn√©es d'authentification\n     */\n    this.isLoggingOut = false;\n  }\n  /**\n   * Authentifie l'utilisateur en envoyant une requ√™te POST √† /api/auth/login\n   * @param credentials Objet contenant l'email et le mot de passe\n   * @returns Observable avec la r√©ponse du backend (JWT, userId, role)\n   */\n  login(credentials) {\n    return this.http.post(`${this.apiUrl}/login`, credentials).pipe(tap(response => {\n      console.log('R√©ponse login re√ßue:', response);\n      const decodedToken = jwtDecode(response.accessToken);\n      console.log('Decoded Token:', decodedToken);\n      const username = decodedToken.username || decodedToken.name || '';\n      this.storeAuthData(response.accessToken, response.userId, response.role, username);\n    }), catchError(this.handleError));\n  }\n  /**\n   * Stocke le JWT, l'ID utilisateur, et le r√¥le dans localStorage\n   * @param jwt Le token JWT\n   * @param userId L'ID de l'utilisateur\n   * @param role Le r√¥le de l'utilisateur (ADMIN, SECURITY, MANAGER, EMPLOYEE)\n   */\n  storeAuthData(token, userId, role, username) {\n    localStorage.setItem('accessToken', token);\n    localStorage.setItem('userId', userId.toString());\n    localStorage.setItem('role', role);\n    if (username) {\n      localStorage.setItem('username', username);\n    }\n    console.log('‚úÖ Donn√©es auth stock√©es');\n  }\n  clearAuthData() {\n    console.log('üßπ Suppression des donn√©es auth...');\n    ['accessToken', 'jwt', 'userId', 'role', 'username'].forEach(key => {\n      localStorage.removeItem(key);\n      sessionStorage.removeItem(key);\n    });\n  }\n  /**\n   * R√©cup√®re le JWT depuis localStorage\n   * @returns Le JWT ou null si non pr√©sent\n   */\n  getJwt() {\n    const token = localStorage.getItem('accessToken');\n    if (!token) return null;\n    try {\n      const decoded = jwtDecode(token);\n      const expiry = decoded.exp * 1000; // Convertir en millisecondes\n      if (expiry < Date.now()) {\n        console.warn('‚ö†Ô∏è Token expir√©, suppression');\n        this.clearAuthData();\n        return null;\n      }\n      return token;\n    } catch (e) {\n      console.error('Erreur de d√©codage du token:', e);\n      this.clearAuthData();\n      return null;\n    }\n  }\n  /**\n   * R√©cup√®re l'ID utilisateur depuis localStorage\n   * @returns L'ID utilisateur ou null si non pr√©sent\n   */\n  getUserId() {\n    const userId = localStorage.getItem('userId');\n    return userId ? parseInt(userId, 10) : null;\n  }\n  /**\n   * R√©cup√®re le r√¥le depuis localStorage\n   * @returns Le r√¥le ou null si non pr√©sent\n   */\n  getRole() {\n    return localStorage.getItem('role');\n  }\n  getusername() {\n    return localStorage.getItem('username');\n  }\n  /**\n   * V√©rifie si l'utilisateur est connect√©\n   * @returns true si un JWT valide est pr√©sent, false sinon\n   */\n  isLoggedIn() {\n    const jwt = this.getJwt();\n    return !!jwt; // Simplifi√©, tu peux ajouter une v√©rification d'expiration si n√©cessaire\n  }\n\n  getUserFromToken() {\n    const token = this.getJwt();\n    if (!token) return null;\n    try {\n      return jwtDecode(token);\n    } catch (e) {\n      return null;\n    }\n  }\n  getUserRoleFromToken() {\n    const token = this.getJwt();\n    if (!token) return null;\n    try {\n      return jwtDecode(token);\n    } catch (e) {\n      return null;\n    }\n  }\n  logout() {\n    if (this.isLoggingOut) return;\n    this.isLoggingOut = true;\n    const token = this.getJwt();\n    const http$ = token ? this.http.post('http://localhost:8075/api/auth/logout', {}, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    }) : this.http.post('noop', {}).pipe(); // appel bidon si pas de token\n    http$.pipe(finalize(() => {\n      this.isLoggingOut = false;\n      /* --- purge toujours --- */\n      this.clearAuthData();\n      this.router.navigate(['/login']); // redirection SPA\n    })).subscribe({\n      next: () => console.log('‚úÖ D√©connexion c√¥t√© serveur'),\n      error: err => console.warn('‚ö†Ô∏è D√©connexion serveur impossible :', err)\n    });\n  }\n  /**\n   * G√®re les erreurs HTTP\n   * @param error L'erreur HTTP\n   * @returns Observable avec un message d'erreur\n   */\n  handleError(error) {\n    let errorMessage = 'Une erreur est survenue. Veuillez r√©essayer.';\n    if (error.status === 401) {\n      errorMessage = 'Email ou mot de passe incorrect.';\n    } else if (error.status === 0) {\n      errorMessage = 'Impossible de se connecter au serveur. V√©rifiez votre connexion.';\n    }\n    return throwError(() => new Error(errorMessage));\n  }\n  isAdmin() {\n    // Decode JWT to check role (simplified, use a library like jwt-decode)\n    const token = this.getJwt();\n    if (token) {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      return payload.role === 'Admin';\n    }\n    return false;\n  }\n  static {\n    this.…µfac = function AuthService_Factory(t) {\n      return new (t || AuthService)(i0.…µ…µinject(i1.HttpClient), i0.…µ…µinject(i2.Router));\n    };\n  }\n  static {\n    this.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n      token: AuthService,\n      factory: AuthService.…µfac,\n      providedIn: 'root'\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}